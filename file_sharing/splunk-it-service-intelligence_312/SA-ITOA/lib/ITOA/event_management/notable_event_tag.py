# Copyright (C) 2005-2018 Splunk Inc. All Rights Reserved.

import time

from splunk.appserver.mrsparkle.lib import i18n
from base_event_management import BaseEventManagement
from notable_event_utils import Audit, MethodType

from splunk.auth import getCurrentUser
from splunk.util import normalizeBoolean
from splunk import RESTException

from ITOA.itoa_common import get_current_utc_epoch

class NotableEventTag(BaseEventManagement):

    """
    Used to store tag(s) for given event
    Schema for tags are as follows

    Tag Schema
    {
        _key: random key generated by kv store,
        event_id:  event id
        object_type: notable_event_tag,
        create_time: mod time,
        mod_time: epoch,
        user: user id,
        owner: owner id,
        tag_name: tag name
    }

    Note: this code chunk would be similar to tag code but I kept is different because logic may change along
         the line of new feature requirement so I kept it different then share that code.
    """

    def __init__(self, session_key, current_user_name=None, collection='itsi_notable_event_tag',
                 object_type='notable_event_tag', user='nobody',
                 audit_token_name='Auto Generated ITSI Notable Index Audit Token', **kwargs):
        # Initialized base event object
        """
        Initialized
        @param session_key: session key
        @param collection: collection name
        @param object_type: object type
        @param user: user context
        @param audit_token_name: audit token
        @param kwargs: extra args
        @return:
        """
        super(NotableEventTag, self).__init__(
            session_key, collection, object_type, user, current_user_name
        )
        self.audit = Audit(self.session_key, audit_token_name=audit_token_name,
                           audit_host=kwargs.get('audit_host'),
                           audit_source=kwargs.get('audit_source', 'Notable Event Audit'),
                           audit_sourcetype=kwargs.get('audit_sourcetype', 'stash'))

        self.event_id_key = 'event_id'
        self.create_time_key = 'create_time'
        self.mod_time_key = 'mod_time'
        self.tag_name_key = 'tag_name'
        self.user_key = 'user'
        self.owner_key = 'owner'

    def pre_processing(self, data_list, method):
        """
        Perform check and also add user and time information in the stanza

        @type data_list: list
        @param data_list: list of data to validate and add time, user info etc

        @type method: basestring
        @param method: method type

        @rtype: list
        @return: It updates list in place and also return it back as well
        """
        if not isinstance(data_list, list):
            raise TypeError(_('Data is not a valid list, actual type is %s'), type(data_list))
        for data in data_list:
            # Make sure data is valid dict
            if not isinstance(data, dict):
                raise TypeError(_('Data is not a valid dictionary.'))
            session_user = getCurrentUser().get('name')
            user = session_user if session_user else self.owner
            time_value = get_current_utc_epoch()
            if method == MethodType.CREATE:
                if not (self.event_id_key in data and self.tag_name_key in data):
                    raise TypeError(_('data does not contain either %s or %s') % (self.event_id_key, self.tag_name_key))
                # Add mod time, create time
                data[self.create_time_key] = time_value
                data[self.owner_key] = user
            if method != MethodType.DELETE:
                # Need to set it for create and update
                data[self.mod_time_key] = time_value
                data[self.user_key] = user
        return data_list

    def create(self, data, **kwargs):
        """
        To create new tag
        @type data: dict
        @param data: data which hold comment and event id in format of
            {
             'event_id' : <event id>,
             'tag_name' : <tag  name string>
             }
        @type kwargs: dict
        @param kwargs: kv args which holds extra settings

        @rtype: dict {'_key': <key>}
        @return: id of generated tag document
        """
        # Check if tag already exist
        all_tags = self.get(data.get(self.event_id_key), is_event_id=True)
        for tag in all_tags:
            if tag.get(self.tag_name_key) == data.get(self.tag_name_key):
                raise RESTException(statusCode=409, msg=_('tag_name=%s already exists.') % data.get(self.tag_name_key))
        result = super(NotableEventTag, self).create(data, **kwargs)
        self.audit.send_activity_to_audit(data, 'New tag name=%s is created'%data.get(self.tag_name_key), 'Tag created')
        return result

    def get(self, object_id, **kwargs):
        """
        Get operation is supported for both. User either get only one tag by passing object_id as _key of KV store
        or object_id can be passed as event_id to get all tags of given event_id - only caveat is that user needs
        to set 'is_event_id' flag to True. By default, this flag is False

        @param object_id:
        @param kwargs:
        @return:
        """
        if not isinstance(object_id, basestring):
            raise TypeError(_('object_id=%s is not valid string.') % object_id)

        is_event_id = normalizeBoolean(kwargs.get('is_event_id', False))
        if not is_event_id:
            return super(NotableEventTag, self).get(object_id)
        else:
            filter_data = {'$or': [{self.event_id_key: object_id}]}
            return super(NotableEventTag, self).get_bulk(None, filter_data=filter_data)

    def update(self, object_id, data, is_partial_update=False, **kwargs):
        """
        Update any existing tag name

        Note: object_id is _key of kv store which stores tag itself

        @type object_id: basestring
        @param object_id: object id

        @type data: dict
        @param data: data

        @type is_partial_update: bool
        @param is_partial_update: flag to do partial update

        @type kwargs: dict
        @param kwargs: Extra parameters

        @rtype: dict
        @return: return dict which holds updated keys
        """
        result = super(NotableEventTag, self).update(object_id, data, is_partial_update=is_partial_update, **kwargs)
        self.audit.send_activity_to_audit(data, 'Tag name=%s is updated'%data.get(self.tag_name_key),
                                          'Tag updated')
        return result

    def delete(self, object_id, **kwargs):
        """
        Delete is supported for both _key and event_id. User either delete only one tag by passing object_id as _key of KV store
        or object_id can be passed as event_id to delete all tags of given event_id - only caveat is that user needs
        to 'is_event_id' flag to true. Default this flag is false

        @type object_id: basestring
        @param object_id: object id

        @type kwargs: dict
        @param kwargs: extra params

        @return: None
        """
        if not isinstance(object_id, basestring):
            raise TypeError(_('object_id=%s is not valid string.') % object_id)

        is_event_id = normalizeBoolean(kwargs.get('is_event_id', False))
        if not is_event_id:
            deleted_tag = self.get(object_id, **kwargs)
            super(NotableEventTag, self).delete(object_id, **kwargs)
            self.audit.send_activity_to_audit(deleted_tag, 'Tag name=%s is deleted'%deleted_tag.get(self.tag_name_key),
                                              'Tag deleted')
        else:
            filter_data = {'$or': [{self.event_id_key: object_id}]}
            tags = self.get(object_id, filter_data=filter_data, **kwargs)
            super(NotableEventTag, self).delete_bulk(object_id, filter_data=filter_data, **kwargs)
            for tag in tags:
                self.audit.send_activity_to_audit(tag, 'Tag name=%s is deleted'%tag.get(self.tag_name_key),
                                                  'Tag deleted')

    def create_bulk(self, data_list, **kwargs):
        raise NotImplementedError(_('%s operation is not supported for this %s object type') % ('create_bulk',
                                                                                           self.object_type))

    def get_bulk(self, object_ids, **kwargs):
        raise NotImplementedError(_('%s operation is not supported for this %s object type') % ('get_bulk',
                                                                                           self.object_type))

    def update_bulk(self, object_ids, data_list, is_partial_update=False, **kwargs):
        raise NotImplementedError(_('%s operation is not supported for this %s object type') % ('update_bulk',
                                                                                           self.object_type))

    def delete_bulk(self, object_ids, **kwargs):
        raise NotImplementedError(_('%s operation is not supported for this %s object type') % ('delete_bulk',
                                                                                           self.object_type))
