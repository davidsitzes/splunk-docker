# Copyright (C) 2005-2018 Splunk Inc. All Rights Reserved.

from splunk.appserver.mrsparkle.lib import i18n
from itoa_bulk_import_common import (UPSERT_UPDATE_TYPE,
                                     REPLACE_UPDATE_TYPE,
                                     APPEND_UPDATE_TYPE,
                                     DEFAULT_UPDATE_TYPE)

from itsi.itsi_utils import ITOAInterfaceUtils
import datetime

# try:  # noqa: F401
#     from typing import Iterable, Iterator, Sequence, Dict, List, Text, Any, Optional, Union, Callable, Tuple, Mapping  # noqa: F401
#     from itoa_bulk_import_entity_relationship_cache import EntityRelationshipCache  # noqa: F401
# except:  # noqa: F401
#     pass  # noqa: F401


class ImportedEntityRelationship(object):
    """
    Represents a entity relationship to be imported.
    """

    def __init__(self, imported_entity_relationship, user='nobody', source='unknown'):
        # type: (Dict, Text, Text) -> None
        """
        Initialize a object representing entity_relationship

        @type imported_entity_relationship: dict
        @param imported_entity_relationship: A dictionary representation of the entity relationship
        as generated by the import parser

        @type user: basestring
        @param user: The current user, used to track who's responsible for adding this entity relationship

        @type source: basestring
        @param source: The source of the current upload

        """
        self.subject_identifier = imported_entity_relationship['subject_identifier']
        self.object_identifier = imported_entity_relationship['object_identifier']
        self.predicate = imported_entity_relationship['predicate']

        self._key = imported_entity_relationship.get('_key', '') or ITOAInterfaceUtils.generate_backend_key()

        current_time = str(datetime.datetime.now())

        self.create_by = user
        self.create_source = source
        self.create_time = current_time

        self.mod = [{
            'mod_by': user,
            'mod_source': source,
            'mod_time': current_time
        }]

    def to_storage_repr(self):
        # type: (EntityRelationshipCache) -> Dict[str, Any]
        """
        Returns a version of the entity relationship suitable for sending to Storage.

        @rtype: dict
        @return: A dict representation of entity relationship.
        """
        object_type = 'entity_relationship'

        to_storage_object = {
            '_key': self._key,
            '_type': object_type,
            'subject_identifier': self.subject_identifier,
            'object_identifier': self.object_identifier,
            'predicate': self.predicate,
            'create_by': self.create_by,
            'create_source': self.create_source,
            'create_time': self.create_time,
            'mod': self.mod,
            'object_type': object_type
        }

        return to_storage_object

    def __str__(self):
        # type: () -> str
        import pprint
        return pprint.pformat(self.to_storage_repr(), indent=4)

    def update_with_entity_relationship_from_storage(self, other_entity_relationship, strategy=DEFAULT_UPDATE_TYPE):
        # type: (StorageEntityRelationship, str) -> ImportedEntityRelationship
        """
        Update this entity relationship with data from an entity relationship found in storage, if any.

        @type other_entity_relationship: object of StorageEntityRelationship
        @param other_entity_relationship: An entity relationship object from storage

        @type strategy: basestring
        @param strategy: How the two objects are to interact to perform the update

        @rtype: object of ImportedEntityRelationship
        @return: A updated ImportedEntityRelationship
        """
        def update_by_append(from_storage):
            # type: (StorageEntityRelationship) -> None
            raise RuntimeError(_("Merge update called when strategy is append, cannot handle."))

        def update_by_replace(from_storage):
            # type: (StorageEntityRelationship) -> None
            self._key = from_storage._key
            self.mod = self.mod or from_storage.mod

        def update_by_upsert(from_storage):
            # type: (StorageEntityRelationship) -> None
            self._key = from_storage._key
            # TODO: merge mod. Will address it in life cycle management
            self.mod = self.mod or from_storage.mod

        update_strategies = {
            UPSERT_UPDATE_TYPE: update_by_upsert,
            REPLACE_UPDATE_TYPE: update_by_replace,
            APPEND_UPDATE_TYPE: update_by_append
        }

        update_strategies[strategy](other_entity_relationship)

        # Preserve original information
        self._key = other_entity_relationship._key
        self.create_by = other_entity_relationship.create_by
        self.create_source = other_entity_relationship.create_source
        self.create_time = other_entity_relationship.create_time

        return self


class StorageEntityRelationship(object):
    """
    Represents an entity relationship as retrieved from Storage.
    """

    def __init__(self, storage_entity_relationship):
        # type: (Dict[Text, Any]) -> None
        """
        Unpack a entity relationship from storage into a type that can be used for replace/upsert in the
        ImportedEntityRelationship

        @type storage_entity_relationship: object
        @param storage_entity_relationship: An entity relationship object as retrieved from the backend.
        """
        self._key = storage_entity_relationship['_key']
        self.subject_identifier = storage_entity_relationship['subject_identifier']
        self.object_identifier = storage_entity_relationship['object_identifier']
        self.predicate = storage_entity_relationship['predicate']

        self.create_by = storage_entity_relationship['create_by']
        self.create_source = storage_entity_relationship['create_source']
        self.create_time = storage_entity_relationship['create_time']

        self.mod = storage_entity_relationship['mod']
