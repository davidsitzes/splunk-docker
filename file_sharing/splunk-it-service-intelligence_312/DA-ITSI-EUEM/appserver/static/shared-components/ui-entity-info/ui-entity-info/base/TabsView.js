define(function(require) {
	var $ = require('jquery');
    var _ = require('underscore');
    var Backbone = require('backbone');
    var mvc = require('splunkjs/mvc');

    // These requires are put here in order to get rid of dependency on tabs.js
    require('bootstrap.tab');
    require('css!shared-components/ui-entity-info/ui-entity-info/base/Tabs.css');

    // Endpoint to hit to retrieve current user context
    var USER_CONTEXT_ENDPOINT = '/authentication/current-context';

    /**
      * View for tabs in the ITSI Drilldown Module
      * The view is dynamically generated by pulling the ordering of tabs from the
      * respective conf file, and then pulling the metadata associated with each tab
      * in the ordered list.  Once all this information has been fetched, the view is rendered
    **/
    var TabsView = Backbone.View.extend({

        // This template is used to generate new tabs in the view
        tabTemplate: _.template([
            '<li>',
            '<a href="#" class="toggle-tab" data-toggle="tab" data-token=<%= control_token%>>',
            '<span><%=title%></span>',
            '<% if (extendable_tab && can_delete) { %>',
            '<span class="btn btn-close">&times;</span>',
            '<% } %>',
            '</a></li>']
            .join('\n')
        ),
        panelTemplate: _.template(
            '<option value=<%= option_value%>><%= option_name%></option>'
        ),
        loadingPanelsMessage: '<option value="loading-please-wait">Loading...</option>',

        // Object that maps the prebuilt panel's name to its associated app
        prebuiltPanels: {},

        /* A list of users that have the ability to use extendable tabs
        * TODO: move this somewhere else when authentication is actually implemented
        */
        allowedRoles: null,

        // Flag if current user can edit extendable tabs in UI
        canEditExtendableTabs: false,

        /* This HTML snippet is appended to TabsView after all other tabs have been entered, to provide
         * new tab creation functionality
         */
        newTab: [
            '<li>',
            '<a id="new-tab" href="#" class="toggle-tab" data-toggle="tab modal" data-token="new"',
            'data-target="#new-tab-modal">+</a>',
            '</li>']
            .join('\n'),

        /* This HTML snippet provides the modal to save tabs.  This is appended to the view in order to simplify
         * the simpleXML for the application page.
         */
        modal: [
            '<div class="modal-dialog modal-lg">',
            '<div class="modal-content">',
            '<div class="modal-header">',
            '<button type="button" class="close" data-dismiss="modal" ',
            'aria-label="Close"><span aria-hidden="true">X</span></button>',
            '<h4 class="modal-title">Create a new tab</h4>',
            '</div>',
            '<div class="modal-body">',
            '<div id="title-container">',
            '<label for="tab-title">Tab Title:</label>',
            '<input type="text" id="tab-title"></input>',
            '</div>',
            '<div>',
            '<label for="select-panels">Select panels:</label>',
            '<div>',
            '<select id="to-select" class="modal-select" multiple></select>',
            '<select id="is-select" class="modal-select" multiple></select>',
            '</div>',
            '<div class="select-buttons-center">',
            '<button id="remove-selected-panels">&lt;&lt;</button>',
            '<button id="add-selected-panels">&gt;&gt</button>',
            '</div>',
            '<div>',
            '<label id="modal-message" for="message"></label>',
            '</div>',
            '<div class="modal-footer">',
            '<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>',
            '<button type="button" id="save-new-tab" class="btn btn-primary">Save new tab</button>',
            '</div>',
            '</div>',
            '</div>']
            .join('\n'),

        deleteModal: [
            '<div class="modal-dialog modal-lg">',
            '<div class="modal-content">',
            '<div class="modal-header">',
            '<button type="button" class="close" data-dismiss="modal" ',
            'aria-label="Close"><span aria-hidden="true">X</span></button>',
            '<h4 class="modal-title">Confirm Delete</h4>',
            '</div>',
            '<div class="modal-body">',
            '<div id="delete-title-container">',
            '<h1>Are you sure you want to delete this tab?</h1>',
            '</div>',
            '</div>',
            '<div class="modal-footer">',
            '<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>',
            '<button type="button" id="delete-tab" class="btn-danger">Delete tab</button>',
            '</div>',
            '</div>',
            '</div>']
            .join('\n'),
        events: {
            'shown' : 'setActiveTabToken',
            'click #new-tab' : 'addTabModal',

            // These are events tied to the modal saving new tabs
            'click #add-new-tab' : 'addNewTab',
            'click #save-new-tab' : 'saveNewTab',
            'click #add-selected-panels' : 'addSelectedPanels',
            'click #remove-selected-panels' : 'removeSelectedPanels',
            'click .btn-close' : 'deleteTabModal',
            'click #delete-tab' : 'deleteTab'
        },

        /* Had to change 'el' since some event handlers I added only work when the target element
         * is a child of the 'el' in Backbone
         */
        el: "#tabs_panel",

        /**
          * When the view is initialized, a fetch() is immediately called on the accompanying
          * collection.  Once this fetch finishes successfully, the view's render method gets
          * called
          * @constructor
          * @param {object} options
        **/
        initialize: function(options) {
            this.collection = options.collection;

            // Added options so that each TabsView can be customized for modules
            this.dash_script = options.dash_script;
            this.dash_stylesheet = options.dash_stylesheet;
            this.allowedRoles = options.allowedRoles;

            this.setEditPrivileges().done(_.bind(function() {
                this.collection.fetch()
                .done(_.bind(this.render, this))
                .fail(function() {
                    console.error("Failed to load tabs from conf file.");
                });
            }, this));
        },


        /**
          * Used to move the panel names from each multiselect window to the other
          * The base method for both of the methods below
          * @params {string} from
          * @params {string} to
        **/
        moveSelectedPanels: function(from, to) {
            $(from).remove(from + " > option:selected");
            $(to).append($(from + " > option:selected"));
        },

        addSelectedPanels: function(event) {
            this.moveSelectedPanels('#to-select', '#is-select');
        },

        removeSelectedPanels: function(event) {
            this.moveSelectedPanels('#is-select', '#to-select');
        },

        /**
          * Determines the level of privilege of the logged in user so that edit options
          * to extendable tabs may or may not be provided
          *
          * TODO: Move to a new model when actual access control gets set up.
          *
        **/
        setEditPrivileges: function() {
            return this.collection.splunkService.get(USER_CONTEXT_ENDPOINT)
                .done(_.bind(function(response) {
                    var responseObj = JSON.parse(response);
                    var existingRoles = responseObj['entry'][0]['content']['roles'];
                    if (! _.isEmpty(_.intersection(this.allowedRoles, existingRoles))) {
                        this.canEditExtendableTabs = true;
                    }
                }, this))
                .fail(function() {
                    console.error("Failed to retrieve current user context.  Extendable tabs disabled by default");
                });
        },

        /**
          * The active tab is selected, and then the token is set for that tab, and all of
          * the non-active tabs get their tokens unset (so that the panels don't appear)
        **/
        setActiveTabToken: function(event) {
            // Since delete button is within the tab container, do not run this if delete is clicked
            if ($(event.target).attr('id') === 'delete-tab-modal') {
                return false;
            }
            var activeTabToken = $('#tabs-container > li.active > a').data('token');

            /* This generates all the data tokens to unset when doing a tab change
             * Side effect: search will be re-triggered each time tab switch occurs
             */
            var unsetTokens = _.without(this.collection.pluck('control_token'), activeTabToken);

            // Unset the previous search tokens, and set the active one
            var tokens = mvc.Components.getInstance('submitted');
            _.each(unsetTokens, function(token) {
                tokens.unset(token);
            });

            tokens.set(activeTabToken, '');
            console.info('Set the token for the active tab (' + activeTabToken + ')');
        },

        /**
          * Transforms the strings that were pulled (row.0, row.1) into indexes in an array, and each
          * index of that array will be transformed into another array for each panel.  Either of length
          * 2 or 3, based on the rendering scheme.
        **/

        generateRowsAndPanels: function() {
            var selectedPanels = _.map($("#is-select > option"), function(panel) {
                return $(panel).text();
            });

            // The rendering scheme
            var renderPerRow = (selectedPanels.length <= 4 && selectedPanels.length != 3) ? 2 : 3;

            // Considered doing a _.mixin for this, to split into n arrays of length renderPerRow
            var count = 0;
            var splitIntoRows = [];
            while (count < selectedPanels.length) {
                splitIntoRows.push(selectedPanels.slice(count, count + renderPerRow));
                count += renderPerRow;
            }

            // Transforms into objects for each panel
            return _.map(splitIntoRows, function(row) {
                return _.map(row, function(panel) {
                    return {
                        appName: this.prebuiltPanels[panel],
                        panelName: panel
                    };
                }, this);
            }, this);
        },


        /**
          * Refreshes the XML file by hitting endpoint, and rewriting file with new stanza information
          * relating to panels
        **/
        refreshXmlEndpoint: function() {
            console.warn("Refreshing XML....");
            this.collection.refreshXml(this.dash_script, this.dash_stylesheet)
            .done(function() {
                console.info("XML refreshed!");
                window.location.reload();
            });
        },

        /**
          * This logic adds a new tab to the collection of tabs.  Validation is done,
          * and if the title is empty or is identical to another existing tab, error messages
          * are given, and the user has to select another tab name
        **/
        addNewTab: function(event) {
            event.preventDefault();

            /* Tab control_token gets dynamically generated from the title by lowercasing the title, and 
             * prefixing 'control_' and replacing all spaces with '-'.  Ex: "TEST TAB TITLE" => "test-tab-title"
             */
            var control_token = 'control_'+$('#tab-title').val().trim().toLowerCase().replace(/\s/g, "-");

            /* Trim the title so that we don't allow any sort of blank title, or tab 
             * title of the likes (where "ExistingTab" is present, saving as "    ExistingTab  ")
             */
            var tabTitle = $('#tab-title').val().trim();

            /* Generates tabId for the tab. 
             */
            var tabId = tabTitle.toLowerCase();

            if (_.isEmpty(tabTitle)) {
                $('#modal-message').addClass('modal-error');
                $('#modal-message').text('You must enter a title for this new tab!');
                return false;
            }
            else if (_.contains(_.pluck(this.collection.toJSON(), 'title'), tabTitle)) {
                $('#modal-message').addClass('modal-error');
                $('#modal-message').text('This title already exists!  Please enter another one.');
                return false;
            }

            // Generates rows and panels to add to a panel
            var rowPanelOrdering = this.generateRowsAndPanels();

            this.collection.add({
                control_token: control_token,
                title: tabTitle,
                rowsAndPanels: rowPanelOrdering,
                // Any user-added tabs are automatically extendable tabs
                extendable_tab: true,
                tabId: tabId
            });

            return {
                tabAddedPanels: (! _.isEmpty(rowPanelOrdering))
            };
        },

        /**
          * This function first makes a check and sees if the tab can be saved (based on
          * whether title vas valid), and then proceeds to save the tab and add the newly
          * saved tab to the view by re-rendering the entire view
        **/
        saveNewTab: function(event) {
            var addedNewTabs = this.addNewTab(event);
            var addedPanels = _.isObject(addedNewTabs) ? addedNewTabs['tabAddedPanels'] : false;
            var reRender = _.bind(this.render, this);

            // If new tab was not added due to error, do not save
            if (! addedNewTabs) {
                return false;
            }

            // Refresh XML endpoint
            var refreshXmlEndpoint = _.bind(this.refreshXmlEndpoint, this);

            // Button text is changed so that it indicates that save is in progress
            $('#save-new-tab').text('Saving...');
            $('#save-new-tab').addClass('disabled');

            this.collection.save().done(function(promise) {
                console.info('New tab has been saved successfully!');
                $('#modal-message').removeClass('modal-error');
                $('#modal-message').addClass('modal-success');
                $('#modal-message').text('Your new tab has saved successfully');

                // Re-render the view
                reRender();
                _.delay(function() {
                    $('#new-tab-modal').modal('hide');
                }, 1200);

                // Refreshes XML right after if new tab contained panels
                if (addedPanels) {
                    refreshXmlEndpoint();
                }
            })

            // Accounts for tab failure.  Doesn't close modal window.
            .fail(function(response, jqXHR, textStatus) {
                console.error('Failed to save tab.  Reason: ' + response.responseText);
                $('#save-new-tab').text('Save new tab');
                $('#save-new-tab').removeClass('disabled');
                $('#modal-message').addClass('modal-error');
                $('#modal-message').text('Failed to save tab.  Reason: ' + response.responseText);
            });
            return this;
        },

        /**
          * Deletes a tab from the view in the modules.  Does NOT remove stanza information related
          * to the tab, only removes it from the list of tabs in the defined view
        **/
        deleteTab: function(event) {
            var deleteTabControlToken = $(event.target).data('token');

            var reRender = _.bind(this.render, this);
            var refreshXmlEndpoint = _.bind(this.refreshXmlEndpoint, this);

            /* Gets the tab model to delete from the collection, based on the set data token in delete button
             * Also prevent the deletion of a non-extendable tab (via UI manipulation, etc.)
             */
            var tabToDelete = this.collection.find(function(tab) {
                return (tab.get('control_token') === deleteTabControlToken) && tab.get('extendable_tab');
            });

            // This shouldn't happen, but protection block anyway if model to remove doesn't exist
            if (tabToDelete === null) {
                console.error("Unable to delete tab model.  Data does not exist in collection!");
                return false;
            }

            // Delete the tab from the local collection
            this.collection.remove(tabToDelete);

            // If there was any panel XML associated with this, remove the control_token
            var tokens = mvc.Components.getInstance('submitted');
            tokens.unset(tabToDelete.get('control_token'));

            /* Finally, save the collection.  Since no stanzas are deleted, the regular save function should
             * work
             */
            console.warn("Deleting tab " + deleteTabControlToken + "....");
            this.collection.save().done(function() {
                console.info("Tab deleted successfully!");
                // Unset the data token associated with this delete button
                $(event.target).data('token', '');
                reRender();
                _.delay(function() {
                    $('#delete-tab-modal').modal('hide');
                }, 1200);

                // If deleted tab had associated panels, trigger refresh XMl and reload
                if (! _.isEmpty(tabToDelete.get('rowsAndPanels'))) {
                    refreshXmlEndpoint();
                }
            });
            return this;
        },

        /**
          * Pops up a modal to delete the tab.  Uses a trick to set the delete button's data token
          * to the name of the control token taken from the tab that's X button was clicked
        **/
        deleteTabModal: function(event) {
            $('#delete-tab-modal').modal('show');

            // Sets the data to delete on the button itself
            var tabToDelete = $(event.target).parent().data('token');
            $('#delete-tab').data('token', tabToDelete);
        },

        /**
          *  Renders the modal on top of page when '+' is clicked, and then populates
          *  the panel selection multiselect with a list of possible panels
        **/
        addTabModal: function(event) {
            $('#new-tab-modal').modal('show');

            // Renders the list of the panel names
            var renderPanelNames = _.bind(this.renderPanelNames, this);

            // Do not reload the list of panels in multiselect if already there
            if (! _.isEmpty(this.prebuiltPanels)) {
                $('#to-select').empty();
                renderPanelNames(this.prebuiltPanels);
            }

            else {
                $("#to-select").append(this.loadingPanelsMessage);
                this.collection.getPrebuiltPanels().done(function(panelMapping) {
                    $('#to-select').empty();
                    renderPanelNames(panelMapping);
                });
            }
        },

        /**
          * Utility method to render panel names inside the popup modal
        **/
        renderPanelNames: function(panels) {
            this.prebuiltPanels = panels;
            _.each(_.keys(panels), function(panel) {
                var panelElm = this.panelTemplate({
                    option_value: panel.toLowerCase(),
                    option_name: panel
                });
                $('#to-select').append(panelElm);
            }, this);
        },

        /** 
          * Pick which tab should be active.
        **/
        assignActiveTab: function() {
            $('#tabs-container > li:first').addClass('active');
        },
        
        /**
          * Renders the view of all the tabs, by enumerating over the collection and generating
          * HTML for each tab based on the given template.  After all the tabs are appended to
          * the container, the first tab is set to be the active one.
        **/
        render: function() {
            var tabString = "";
            _.each(this.collection.models, function(tab) {
                tabString += this.tabTemplate(_.extend({}, tab.pick(['control_token', 'extendable_tab', 'title']),
                    {can_delete: this.canEditExtendableTabs}));
            }, this);

            $('#tabs-container').empty().append(tabString);

            /* Make sure you add new tab at the end if user context permits
             * Also only append modals to DOM if there is a need for it to cut down on render
             */
            if (this.canEditExtendableTabs) {
                $('#tabs-container').append(this.newTab);

                // Dynamically append the modal window after rendering to the page as hidden
                $('#new-tab-modal').empty().append(this.modal);

                // Dynamically append the modal window to delete tabs after rendering to the page as hidden
                $('#delete-tab-modal').empty().append(this.deleteModal);
            }

            this.assignActiveTab();

            // Make sure the active tab panels are enabled
            $("#tabs-container > li.active > a").trigger('shown');
        },
    });

    return TabsView;
});
