<form stylesheet="dashboard/toggle.css" script="dashboard/toggle.js">
  <label>Service Health Score Predictive Analytics</label>
  <init>
    <set token="time1.earliest">-7d</set>
    <set token="time1.latest">now</set>
    <set token="span">5m</set>
    <set token="future_window">6</set>
  </init>
  <fieldset submitButton="false" autoRun="false"></fieldset>
  <row id="Intro">
    <panel>
      <description>this is the label</description>
      <html>The predictive analytics dashboard uses machine learning algorithms to predict the health score value of a selected service. First, you test three different algorithms using various measurements to determine which algorithm has the best overall performance. You can then use this algorithm to create an alert and predict an imminent service outage. Expand the INSTRUCTIONS section to get started.</html>
    </panel>
  </row>
  <row id="collapseinstructions">
    <panel>
      <title>INSTRUCTIONS</title>
      <description>this is the label</description>
      <html>
        <div style="float: right">
		      <img id="imgToggle2" class="toggle" title="Show/hide host processor details" src="/static/app/itsi/dashboard/expand.png"/>
	      </div>
      </html>
    </panel>
  </row>
  <row id="inst">
    <panel>
      <title></title>
      <html>
        <h4>TRAIN</h4>
        <p style="padding-left: 30px;">
          <span class="s4">1. Expand the TRAIN section.</span>
        </p>
<p style="padding-left: 30px;">
          <span class="s4">2. Under</span>
          <span class="s1">
            <strong>Service</strong>, select the service that you want to predict a health score for.</span>
        </p>
<p style="padding-left: 30px;">
          <span class="s1">3. Under <strong>Algorithm</strong>, select the algorithm to use for the prediction. Algorithm descriptions are listed below.</span>
        </p>
        <p style="padding-left: 30px;">
            <span class="s1">
            <strong>Note</strong>: Selecting an algorithm generates the model in the TEST section with the name <em>"itsi_predict_[service_algorithm]"</em>
            </span>
        </p>
<p style="padding-left: 30px;">
          <span class="s1">4. Review the graph of service health scores and KPIs over time, the distribution of service health score values, and the fit model for the selected algorithm.</span>
        </p>

<p style="padding-left: 30px;">
          <span class="s1">5. Repeat steps 3-4 for the remaining algorithms.</span>
        </p>
<p style="padding-left: 30px;"/>
<h4>
          <span class="s1">TEST</span>
        </h4>
                <p style="padding-left: 30px;">
          <span class="s4">6. Expand the TEST section.</span>
        </p>
<p style="padding-left: 30px;">
          <span class="s1">7. Use the time range picker to select the time period to extract and test data.</span>
        </p>
<p style="padding-left: 30px;">
          <span class="s1">8. Click on a model name to test it. Evaluate the R<sup>2</sup> and RMSE values, the difference between the actual and predicted health scores, and the residual error histogram to determine which algorithm performed the best.
          </span>
        </p>
<h4>
          <span class="s1">USE</span>
        </h4>
<p style="padding-left: 30px;">
          <span class="s1">9. Use the best performing algorithm to predict the health score for your service.</span>
        </p>
<p style="padding-left: 30px;">
          <span class="s1"/>
        </p>
<p style="padding-left: 30px;">
          <span class="s1">10. (Optional) Open the prediction in a search and save it as an alert. This ensures that you will be notified of potential service degradation in the future.</span>
        </p>
<p style="padding-left: 30px;">
          <span class="s1"/>
        </p>
</html>
    </panel>
  </row>
  <row id="collapserow">
    <panel>
      <title>TRAIN</title>
      <html>
        <div style="float: right">
		      <img id="imgToggle1" class="toggle" title="Show/hide host processor details" src="/static/app/itsi/dashboard/expand.png"/>
	      </div>
      </html>
    </panel>
  </row>
  <row id="inputs">
    <panel>
      <input type="dropdown" token="service_id" searchWhenChanged="true">
        <label>Service</label>
        <selectFirstChoice>true</selectFirstChoice>
        <fieldForLabel>title</fieldForLabel>
        <fieldForValue>_key</fieldForValue>
        <search>
          <query>| inputlookup service_kpi_lookup | table _key title</query>
          <earliest>-1m</earliest>
          <latest>now</latest>
        </search>
        <change>
          <set token="service">$label$</set>
          <eval token="service_name">replace(lower('service')," ","_")."_".'algo'</eval>
          <eval token="service_name_only">replace(lower('service')," ","_")</eval>
          <unset token="model_name_apply"></unset>
        </change>
      </input>
      <input type="dropdown" token="algo" searchWhenChanged="true">
        <label>Algorithm</label>
        <change>
          <eval token="service_name">replace(lower('service')," ","_")."_".'algo'</eval>
        </change>
        <choice value="LinearRegression">LinearRegression</choice>
        <choice value="RandomForestRegressor">RandomForestRegressor</choice>
        <choice value="GradientBoostingRegressor">GradientBoostingRegressor</choice>
        <default>LinearRegression</default>
      </input>
      <html>
        <p>
          <span style="font-family: 'Helvetica Neue'; font-size: 11pt;">
            <strong>Machine Learning Algorithms:</strong>
          </span>
        </p>
        <br> </br>
<ul style="margin-left: .375in; direction: ltr; unicode-bidi: embed; margin-top: 0in; margin-bottom: 0in;" type="disc">
<li style="margin-top: 0; margin-bottom: 0; vertical-align: middle; color: #454545;">
            <span style="font-family: 'Helvetica Neue'; font-size: 9.0pt;">The <strong>Linear Regression</strong> algorithm fits a linear line to your data, using each input (KPIs and historical service health scores) as an additional dimension. It assumes that your data is normal and is highly scalable.</span>
</li>
<li style="margin-top: 0; margin-bottom: 0; vertical-align: middle; color: #454545;">
            <span style="font-family: 'Helvetica Neue'; font-size: 9.0pt;">The <strong>Random Forest Regressor</strong> algorithm takes the inputs (KPIs and historical service health scores) and forms a random decision tree (a "forest") to determine the output value. This model makes no assumptions about the normalcy of your data, but requires more processing power and takes longer to run.</span>
</li>
<li style="margin-top: 0; margin-bottom: 0; vertical-align: middle; color: #454545;">
            <span style="font-family: 'Helvetica Neue'; font-size: 9.0pt;">The <strong>Gradient Boosting Regressor</strong> algorithm uses a loss function to fit a line to your data, a decision tree, and an additive model to predict the service health score value. The algorithm can continuously learn, but in the dashboard it runs only once. Think of this as a combination of the Random Forest Regressor and Linear Regression.</span>
            <span style="font-family: 'Helvetica Neue'; font-size: 9.0pt;"> This algorithm can continuously learn, but in this dashboard it runs only once.</span>
</li>
</ul>
<p>
          <span style="font-family: 'Helvetica Neue'; font-size: 9.0pt;">
            <em>
              <strong>Note: </strong>The decision to use a particular algorithm usually depends on the type of KPI data in your environment. For example, cyclical data is best suited for the Linear Regression algorithm. For random or more consistent (less cyclical) data, try Random Forest Regressor or Gradient Boosting Regressor.</em>
          </span>
        </p>
      </html>
    </panel>
  </row>
  <row id="shs_time">
    <panel>
      <title>Service Health Score and KPIs Over Time</title>
      <chart>
        <search id="base">
          <query>`get_itsi_summary_index` indexed_itsi_service_id::$service_id$ | timechart limit=0 span=$span$ avg(alert_value) AS "Average Value" avg(health_score) as "Average" BY kpi</query>
          <earliest>$time1.earliest$</earliest>
          <latest>$time1.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <selection>
          <set token="xselection.earliest">$start$</set>
          <set token="xselection.latest">$end$</set>
          <set token="xstart.count">$start.count$</set>
          <set token="xend.count">$end.count$</set>
        </selection>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">log</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">bottom</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
      <html>
        <p align="center">The values of service health scores and KPIs over time. These values are used as inputs to the machine learning model to predict what the service health score will be in 30 minutes. Use this graph to view the input data over the last 7 days.</p>
      </html>
    </panel>
  </row>
  <row id="shs_dist">
    <panel>
      <title>Distribution of Service Health Score Values</title>
      <viz type="Splunk_ML_Toolkit.HistogramViz">
        <search>
          <query>`get_itsi_summary_index` indexed_itsi_service_id::$service_id$ kpi=ServiceHealthScore source=service_health_monitor
| timechart limit=0 span=$span$ avg(health_score) as avg_health_score BY kpi
| `histogram(ServiceHealthScore,100)`</query>
          <earliest>$time1.earliest$</earliest>
          <latest>$time1.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="drilldown">none</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </viz>
      <html>
        <p align="center">A histogram of service health score values over the last 7 days. This distribution shows how often each health score occurs over time. In general, it is best to have normally distributed data. If your health score is almost always the same value (ex. 95) with little or no change over time, then a prediction might not be very informative.</p>
      </html>
    </panel>
    <panel>
      <title>Fit Model</title>
      <input type="time" token="time_fitting" searchWhenChanged="true">
        <label></label>
        <default>
          <earliest>-24h@h</earliest>
          <latest>now</latest>
        </default>
      </input>
      <chart>
        <search>
          <query>`get_itsi_summary_index` indexed_itsi_service_id::$service_id$
| timechart limit=0 span=$span$ avg(alert_value) as value_avg max(alert_value) as value_max min(alert_value) as value_min median(alert_value) as value_median stdev(alert_value) as value_stdev avg(health_score) as avg_health_score BY kpi
| filldown
| eval this_date_hour = strftime(_time, "%H")
| eval this_date_day = strftime(_time, "%w")
| eval this_date_day = this_date_day."_"
| eval this_date_hour = this_date_hour."_"
| reverse
| streamstats window=$future_window$ current=f first("avg_health_score: ServiceHealthScore") as ServiceHealthScoreFromFuture
| reverse
| fit StandardScaler "value*" with_mean=true with_std=true into "itsi_predict_$service_name$_ss"
| fit $algo$ "ServiceHealthScoreFromFuture" from "SS_*" "this_*" into "itsi_predict_$service_name$"
| timechart span=$span$ max("predicted(ServiceHealthScoreFromFuture)") as "Predicted ServiceHealthScore"</query>
          <earliest>$time_fitting.earliest$</earliest>
          <latest>$time_fitting.latest$</latest>
        </search>
        <option name="charting.axisLabelsX.majorLabelStyle.overflowMode">ellipsisNone</option>
        <option name="charting.axisLabelsX.majorLabelStyle.rotation">0</option>
        <option name="charting.axisTitleX.visibility">visible</option>
        <option name="charting.axisTitleY.visibility">visible</option>
        <option name="charting.axisTitleY2.visibility">visible</option>
        <option name="charting.axisX.abbreviation">none</option>
        <option name="charting.axisX.scale">linear</option>
        <option name="charting.axisY.abbreviation">none</option>
        <option name="charting.axisY.scale">linear</option>
        <option name="charting.axisY2.abbreviation">none</option>
        <option name="charting.axisY2.enabled">0</option>
        <option name="charting.axisY2.scale">inherit</option>
        <option name="charting.chart">line</option>
        <option name="charting.chart.bubbleMaximumSize">50</option>
        <option name="charting.chart.bubbleMinimumSize">10</option>
        <option name="charting.chart.bubbleSizeBy">area</option>
        <option name="charting.chart.nullValueMode">gaps</option>
        <option name="charting.chart.showDataLabels">none</option>
        <option name="charting.chart.sliceCollapsingThreshold">0.01</option>
        <option name="charting.chart.stackMode">default</option>
        <option name="charting.chart.style">shiny</option>
        <option name="charting.drilldown">none</option>
        <option name="charting.layout.splitSeries">0</option>
        <option name="charting.layout.splitSeries.allowIndependentYRanges">0</option>
        <option name="charting.legend.labelStyle.overflowMode">ellipsisMiddle</option>
        <option name="charting.legend.mode">standard</option>
        <option name="charting.legend.placement">bottom</option>
        <option name="charting.lineWidth">2</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
      <html>
        <p align="center">The predicted output of the machine learning model for the time period you select. For example, if you select Last 24 hours, the KPI and health score data for the last 24 hours is given to the model as input. The model uses the data to plot the predicted health score 30 minutes into the future. Predictions are made at 5 minute intervals over the last 24 hours.<br> </br> In general, the prediction is considered better if the shape of this graph is similar to the shape of the <strong>Average: ServiceHealthScore</strong> line in the graph of Service Health Scores and KPIs over time above.
</p>
      </html>
    </panel>
  </row>
  <row>
    <panel>
      <title>TEST</title>
      <html>
        <div style="float: right">
		      <img id="imgToggle3" class="toggle" title="Show/hide host processor details" src="/static/app/itsi/dashboard/expand.png"/>
	      </div>
      </html>
    </panel>
  </row>
  <row id="test1">
    <panel>
      <input type="time" token="time_apply" searchWhenChanged="true">
        <label>Time Period</label>
        <default>
          <earliest>-24h@h</earliest>
          <latest>now</latest>
        </default>
      </input>
      <table>
        <title>Click on model name to test</title>
        <search>
          <query>| listmodels | search name="itsi_predict_$service_name_only$*" NOT type="StandardScaler" |  stats values(name) as model_name by type</query>
          <earliest>-60m@m</earliest>
          <latest>now</latest>
          <sampleRatio>1</sampleRatio>
          <refresh>10s</refresh>
          <refreshType>delay</refreshType>
        </search>
        <option name="count">20</option>
        <option name="dataOverlayMode">none</option>
        <option name="drilldown">cell</option>
        <option name="percentagesRow">false</option>
        <option name="refresh.display">progressbar</option>
        <option name="rowNumbers">false</option>
        <option name="totalsRow">false</option>
        <option name="wrap">true</option>
        <drilldown>
          <set token="model_name_apply">$click.value2$</set>
        </drilldown>
      </table>
    </panel>
    <panel depends="$model_name_apply$">
      <title>R^2 and RMSE</title>
      <single>
        <search>
          <query>
`get_itsi_summary_index` indexed_itsi_service_id::$service_id$
| timechart limit=0 span=$span$ avg(alert_value) as value_avg max(alert_value) as value_max min(alert_value) as value_min median(alert_value) as value_median stdev(alert_value) as value_stdev avg(health_score) as avg_health_score BY kpi
| filldown
| eval this_date_hour = strftime(_time, "%H")
| eval this_date_day = strftime(_time, "%w")
| eval this_date_day = this_date_day."_"
| eval this_date_hour = this_date_hour."_"
| reverse
| streamstats window=$future_window$ current=f first("avg_health_score: ServiceHealthScore") as ServiceHealthScoreFromFuture
| reverse
| apply "$model_name_apply$_ss"
| apply "$model_name_apply$"
| `regressionstatistics("ServiceHealthScoreFromFuture", "predicted(ServiceHealthScoreFromFuture)")`
</query>
          <earliest>$time_apply.earliest$</earliest>
          <latest>$time_apply.latest$</latest>
        </search>
        <option name="colorBy">value</option>
        <option name="colorMode">block</option>
        <option name="drilldown">none</option>
        <option name="numberPrecision">0.00</option>
        <option name="rangeColors">["0xd93f3c","0xf58f39","0x65a637","0xd93f3c","0x555"]</option>
        <option name="rangeValues">[0.5,0.75,0.999,1]</option>
        <option name="showSparkline">1</option>
        <option name="showTrendIndicator">1</option>
        <option name="trellis.enabled">1</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">large</option>
        <option name="trendColorInterpretation">standard</option>
        <option name="trendDisplayMode">absolute</option>
        <option name="unitPosition">after</option>
        <option name="useColors">1</option>
        <option name="useThousandSeparators">1</option>
      </single>
      <html>
        <p align="center">R<sup>2</sup> indicates how well the model explains the variability of the result. 100% (a value of 1) means the model fits perfectly. The closer the value is to 1 (100%) the better the result. <br> </br>RMSE (Root Mean Squared Error) is a measure of the difference between values predicted by the model and the values actually observed. This value depends on the output distribution of the created model, but in general a smaller value is better. Think of this as the average difference between the prediction and the actual service health score value in the future.</p>
      </html>
    </panel>
  </row>
  <row id="test2" depends="$model_name_apply$">
    <panel>
      <title>Actual vs. Predicted Service Health Score</title>
      <chart>
        <search>
          <query>`get_itsi_summary_index` indexed_itsi_service_id::$service_id$
| timechart limit=0 span=$span$ avg(alert_value) as value_avg max(alert_value) as value_max min(alert_value) as value_min median(alert_value) as value_median stdev(alert_value) as value_stdev avg(health_score) as avg_health_score BY kpi
 | eval this_date_hour = strftime(_time, "%H")
| eval this_date_day = strftime(_time, "%w")
| eval this_date_day = this_date_day."_"
| eval this_date_hour = this_date_hour."_"
|reverse
|streamstats window=$future_window$ current=f first("avg_health_score: ServiceHealthScore") as ServiceHealthScoreFromFuture
|reverse
| apply "$model_name_apply$_ss"
| apply "$model_name_apply$"
| table _time, "ServiceHealthScoreFromFuture", "predicted(ServiceHealthScoreFromFuture)"</query>
          <earliest>$time_apply.earliest$</earliest>
          <latest>$time_apply.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="charting.chart">line</option>
        <option name="charting.drilldown">none</option>
        <option name="refresh.display">progressbar</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </chart>
      <html>
        <p align="center">This graph compares the actual service health score to what the model predicted the number should be 30 minutes into the future. The comparison is performed at 5 minute intervals over the time range you selected above. The prediction is considered better if the two lines overlap or are very similar.
</p>
      </html>
    </panel>
    <panel>
      <title>Residual Error Histogram</title>
      <viz type="Splunk_ML_Toolkit.HistogramViz">
        <search>
          <query>
`get_itsi_summary_index` indexed_itsi_service_id::$service_id$
| timechart limit=0 span=$span$ avg(alert_value) as value_avg max(alert_value) as value_max min(alert_value) as value_min median(alert_value) as value_median stdev(alert_value) as value_stdev avg(health_score) as avg_health_score BY kpi
| filldown
| eval this_date_hour = strftime(_time, "%H")
| eval this_date_day = strftime(_time, "%w")
| eval this_date_day = this_date_day."_"
| eval this_date_hour = this_date_hour."_"
| reverse
| streamstats window=$future_window$ current=f first("avg_health_score: ServiceHealthScore") as ServiceHealthScoreFromFuture
| reverse
| apply "$model_name_apply$_ss"
| apply "$model_name_apply$"
| eval residual = 'ServiceHealthScoreFromFuture' - 'predicted(ServiceHealthScoreFromFuture)' | `histogram(residual, 100)` | rename count as "Sample Count", residual as "Residual Error"</query>
          <earliest>$time_apply.earliest$</earliest>
          <latest>$time_apply.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="drilldown">none</option>
        <option name="trellis.enabled">0</option>
        <option name="trellis.scales.shared">1</option>
        <option name="trellis.size">medium</option>
      </viz>
      <html>
        <p align="center">A histogram of the residual error of each service health score during the test period. The residual error is the difference between the observed service health score and the estimated score predicted by the model. In general, it is better if this graph is evenly distributed with values closer to 0.
</p>
      </html>
    </panel>
  </row>
  <row id="test3" depends="$model_name_apply$">
    <panel>
      <title>USE</title>
      <single>
        <title>Predicted service health score in 20-30 minutes:</title>
          <search>
          <query>`get_itsi_summary_index` indexed_itsi_service_id::$service_id$
| timechart limit=0 span=$span$ avg(alert_value) as value_avg max(alert_value) as value_max min(alert_value) as value_min median(alert_value) as value_median stdev(alert_value) as value_stdev avg(health_score) as avg_health_score BY kpi
| filldown
| eval this_date_hour = strftime(_time, "%H")
| eval this_date_day = strftime(_time, "%w")
| eval this_date_day = this_date_day."_"
| eval this_date_hour = this_date_hour."_"
| reverse
| streamstats window=$future_window$ current=f first("avg_health_score: ServiceHealthScore") as ServiceHealthScoreFromFuture
| reverse
| apply "$model_name_apply$_ss"
| apply "$model_name_apply$"| sort -_time | head 3 |stats earliest("predicted(ServiceHealthScoreFromFuture)") as num | eval num = case(num &lt; 0, 0, num&gt;100, 100, true(), round(num, 2))</query>
          <earliest>$time_apply.earliest$</earliest>
          <latest>$time_apply.latest$</latest>
          <sampleRatio>1</sampleRatio>
        </search>
        <option name="drilldown">none</option>
        <option name="refresh.display">progressbar</option>
      </single>
    </panel>
  </row>
</form>
